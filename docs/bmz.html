<!DOCTYPE html>
<html>
<head>
<title>BMZ Algorithm</title>
<meta name="generator" content="http://txt2tags.org">
<link rel="stylesheet" href="DOC.css">
<style>
body{background-color:#fff;color:#000;}
hr{background-color:#000;border:0;color:#000;}
hr.heavy{height:5px;}
hr.light{height:1px;}
img{border:0;display:block;}
img.right{margin:0 0 0 auto;}
img.center{border:0;margin:0 auto;}
table th,table td{padding:4px;}
.center,header{text-align:center;}
table.center {margin-left:auto; margin-right:auto;}
.right{text-align:right;}
.left{text-align:left;}
.tableborder,.tableborder td,.tableborder th{border:1px solid #000;}
.underline{text-decoration:underline;}
</style>
</head>
<body>
<header>
<hgroup>
<h1>BMZ Algorithm</h1>
</hgroup>
</header>
<article>

<div class="body" id="body">

<section~A~>
<h1></h1>
<section>
<h2>Properties</h2>

  <ul>
  <li>Construct MPHFs in linear time.
  </li>
  <li>It is based on cyclic random graphs. This makes it faster than the CHM algorithm.
  </li>
  <li>The resulting MPHFs are not order preserving. 
  </li>
  <li>The resulting MPHFs are more compact than the ones generated by the CHM algorithm and can be stored in <em>4cn</em> bytes, where <em>c</em> is in the range <em>[0.93,1.15]</em>. 
  <p></p>
  </li>
  </ul>

<hr class="light">

</section>
<section>
<h2>History</h2>

<p>
At the end of 2003, professor <a href="http://www.dcc.ufmg.br/~nivio">Nivio Ziviani</a> was
finishing the second edition of his <a href="http://www.dcc.ufmg.br/algoritmos/">book</a>.
During the <a href="http://www.dcc.ufmg.br/algoritmos/">book</a> writing, 
professor <a href="http://www.dcc.ufmg.br/~nivio">Nivio Ziviani</a> studied the problem of generating 
<a href="concepts.html">minimal perfect hash functions</a>
(if you are not familiarized with this problem, see <a href="#papers">[1</a>]<a href="#papers">[2</a>]). 
Professor <a href="http://www.dcc.ufmg.br/~nivio">Nivio Ziviani</a> coded a modified version of 
the <a href="chm.html">CHM algorithm</a>, which was proposed by
Czech, Havas and Majewski, and put it in his <a href="http://www.dcc.ufmg.br/algoritmos/">book</a>.
The <a href="chm.html">CHM algorithm</a> is based on acyclic random graphs to generate 
<a href="concepts.html">order preserving minimal perfect hash functions</a> in linear time. 
Professor <a href="http://www.dcc.ufmg.br/~nivio">Nivio Ziviani</a> 
argued himself, why must the random graph 
be acyclic? In the modified version availalbe in his <a href="http://www.dcc.ufmg.br/algoritmos/">book</a> he got rid of this restriction.
</p>
<p>
The modification presented a problem, it was impossible to generate minimal perfect hash functions
for sets with more than 1000 keys.
At the same time, <a href="http://www.dcc.ufmg.br/~fbotelho">Fabiano C. Botelho</a>,
a master degree student at <a href="http://www.dcc.ufmg.br">Departament of Computer Science</a> in 
<a href="http://www.ufmg.br">Federal University of Minas Gerais</a>,
started to be advised by <a href="http://www.dcc.ufmg.br/~nivio">Nivio Ziviani</a> who presented the problem 
to <a href="http://www.dcc.ufmg.br/~fbotelho">Fabiano</a>.
</p>
<p>
During the master, <a href="http://www.dcc.ufmg.br/~fbotelho">Fabiano</a> and 
<a href="http://www.dcc.ufmg.br/~nivio">Nivio Ziviani</a> faced lots of problems.
In april of 2004, <a href="http://www.dcc.ufmg.br/~fbotelho">Fabiano</a> was talking with a 
friend of him (David Menoti) about the problems
and many ideas appeared.
The ideas were implemented and a very fast algorithm to generate
minimal perfect hash functions had been designed.
We refer the algorithm to as <strong>BMZ</strong>, because it was conceived by Fabiano C. <strong>B</strong>otelho,
David <strong>M</strong>enoti and Nivio <strong>Z</strong>iviani. The algorithm is described in <a href="#papers">[1</a>].
To analyse BMZ algorithm we needed some results from the random graph theory, so 
we invited professor <a href="http://www.ime.usp.br/~yoshi">Yoshiharu Kohayakawa</a> to help us.
The final description and analysis of BMZ algorithm is presented in <a href="#papers">[2</a>].
</p>

<hr class="light">

</section>
<section>
<h2>The Algorithm</h2>

<p>
The BMZ algorithm shares several features with the <a href="chm.html">CHM algorithm</a>.   
In particular, BMZ algorithm is also
based on the generation of random graphs <img class="center" src="figs/img27.png" alt="">, where <img class="center" src="figs/img28.png" alt=""> is in 
one-to-one correspondence with the key set <img class="center" src="figs/img20.png" alt=""> for which we wish to 
generate a <a href="concepts.html">minimal perfect hash function</a>.
The two main differences between BMZ algorithm and CHM algorithm
are as follows: (<em>i</em>)  BMZ algorithm generates random 
graphs <img class="center" src="figs/img27.png" alt=""> with <img class="center" src="figs/img29.png" alt=""> and <img class="center" src="figs/img30.png" alt="">, where <img class="center" src="figs/img31.png" alt="">, 
and hence <img class="center" src="figs/img32.png" alt=""> necessarily contains cycles, 
while CHM algorithm generates <em>acyclic</em> random 
graphs <img class="center" src="figs/img27.png" alt=""> with <img class="center" src="figs/img29.png" alt=""> and <img class="center" src="figs/img30.png" alt="">,
with a greater number of vertices: <img class="center" src="figs/img33.png" alt="">;
(<em>ii</em>) CHM algorithm generates <a href="concepts.html">order preserving minimal perfect hash functions</a>
while BMZ algorithm does not preserve order.  Thus, BMZ algorithm improves
the space requirement at the expense of generating functions that are not
order preserving. 
</p>
<p>
Suppose <img class="center" src="figs/img14.png" alt=""> is a universe of <em>keys</em>.
Let <img class="center" src="figs/img17.png" alt=""> be a set of <img class="center" src="figs/img8.png" alt=""> keys from <img class="center" src="figs/img14.png" alt="">.
Let us show how the BMZ algorithm constructs a minimal perfect hash function <img class="center" src="figs/img7.png" alt="">.
We make use of two auxiliary random functions <img class="center" src="figs/img41.png" alt=""> and <img class="center" src="figs/img55.png" alt="">, 
where <img class="center" src="figs/img56.png" alt=""> for some suitably chosen integer <img class="center" src="figs/img57.png" alt="">, 
where <img class="center" src="figs/img58.png" alt="">.We build a random graph <img class="center" src="figs/img59.png" alt=""> on <img class="center" src="figs/img60.png" alt="">,
whose edge set is <img class="center" src="figs/img61.png" alt="">. There is an edge in <img class="center" src="figs/img32.png" alt=""> for each 
key in the set of keys <img class="center" src="figs/img20.png" alt="">.
</p>
<p>
In what follows, we shall be interested in the <em>2-core</em> of
the random graph <img class="center" src="figs/img32.png" alt="">, that is, the maximal subgraph 
of <img class="center" src="figs/img32.png" alt=""> with minimal degree at 
least 2 (see <a href="#papers">[2</a>] for details).
Because of its importance in our context, we call the 2-core the
<em>critical</em> subgraph of <img class="center" src="figs/img32.png" alt=""> and denote it by <img class="center" src="figs/img63.png" alt="">.
The vertices and edges in <img class="center" src="figs/img63.png" alt=""> are said to be <em>critical</em>.
We let <img class="center" src="figs/img64.png" alt=""> and <img class="center" src="figs/img65.png" alt="">.
Moreover, we let <img class="center" src="figs/img66.png" alt=""> be the set of <em>non-critical</em>
vertices in <img class="center" src="figs/img32.png" alt="">.
We also let <img class="center" src="figs/img67.png" alt=""> be the set of all critical
vertices that have at least one non-critical vertex as a neighbour.
Let <img class="center" src="figs/img68.png" alt=""> be the set of <em>non-critical</em> edges in <img class="center" src="figs/img32.png" alt="">.
Finally, we let <img class="center" src="figs/img69.png" alt=""> be the <em>non-critical</em> subgraph 
of <img class="center" src="figs/img32.png" alt="">.
The non-critical subgraph <img class="center" src="figs/img70.png" alt=""> corresponds to the <em>acyclic part</em>
of <img class="center" src="figs/img32.png" alt="">.
We have <img class="center" src="figs/img71.png" alt="">.
</p>
<p>
We then construct a suitable labelling <img class="center" src="figs/img72.png" alt=""> of the vertices
of <img class="center" src="figs/img32.png" alt="">: we choose <img class="center" src="figs/img73.png" alt=""> for each <img class="center" src="figs/img74.png" alt=""> in such
a way that <img class="center" src="figs/img75.png" alt=""> (<img class="center" src="figs/img18.png" alt="">) is a
minimal perfect hash function for <img class="center" src="figs/img20.png" alt="">.
This labelling <img class="center" src="figs/img37.png" alt=""> can be found in linear time
if the number of edges in <img class="center" src="figs/img63.png" alt=""> is at most <img class="center" src="figs/img76.png" alt=""> (see <a href="#papers">[2</a>] 
for details).
</p>
<p>
Figure 1 presents a pseudo code for the BMZ algorithm.
The procedure BMZ (<img class="center" src="figs/img20.png" alt="">, <img class="center" src="figs/img37.png" alt="">) receives as input the set of
keys <img class="center" src="figs/img20.png" alt=""> and produces the labelling <img class="center" src="figs/img37.png" alt="">.
The method uses a mapping, ordering and searching approach.
We now describe each step.
</p>

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td>procedure BMZ (<img class="center" src="figs/img20.png" alt="">, <img class="center" src="figs/img37.png" alt="">)</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;Mapping (<img class="center" src="figs/img20.png" alt="">, <img class="center" src="figs/img32.png" alt="">);</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;Ordering (<img class="center" src="figs/img32.png" alt="">, <img class="center" src="figs/img63.png" alt="">, <img class="center" src="figs/img70.png" alt="">);</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;Searching (<img class="center" src="figs/img32.png" alt="">, <img class="center" src="figs/img63.png" alt="">, <img class="center" src="figs/img70.png" alt="">, <img class="center" src="figs/img37.png" alt="">);</td>
</tr>
<tr>
<td><strong>Figure 1</strong>: Main steps of BMZ algorithm for constructing a minimal perfect hash function</td>
</tr>
</table>

<hr class="light">

<section>
<h3>Mapping Step</h3>

<p>
The procedure Mapping (<img class="center" src="figs/img20.png" alt="">, <img class="center" src="figs/img32.png" alt="">) receives as input the set 
of keys <img class="center" src="figs/img20.png" alt=""> and generates the random graph <img class="center" src="figs/img59.png" alt="">, by generating 
two auxiliary functions <img class="center" src="figs/img41.png" alt="">, <img class="center" src="figs/img78.png" alt="">.
</p>
<p>
The functions <img class="center" src="figs/img41.png" alt=""> and <img class="center" src="figs/img42.png" alt=""> are constructed as follows.
We impose some upper bound <img class="center" src="figs/img79.png" alt=""> on the lengths of the keys in <img class="center" src="figs/img20.png" alt="">.
To define <img class="center" src="figs/img80.png" alt=""> (<img class="center" src="figs/img81.png" alt="">, <img class="center" src="figs/img62.png" alt="">), we generate 
an <img class="center" src="figs/img82.png" alt=""> table of random integers <img class="center" src="figs/img83.png" alt="">.
For a key <img class="center" src="figs/img18.png" alt=""> of length <img class="center" src="figs/img84.png" alt=""> and <img class="center" src="figs/img85.png" alt="">, we let 
</p>

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><img class="center" src="figs/img86.png" alt=""></td>
</tr>
</table>

<p>
The random graph <img class="center" src="figs/img59.png" alt=""> has vertex set <img class="center" src="figs/img56.png" alt=""> and 
edge set <img class="center" src="figs/img61.png" alt="">.  We need <img class="center" src="figs/img32.png" alt=""> to be 
simple, i.e., <img class="center" src="figs/img32.png" alt=""> should have neither loops nor multiple edges.
A loop occurs when <img class="center" src="figs/img87.png" alt=""> for some <img class="center" src="figs/img18.png" alt="">.
We solve this in an ad hoc manner: we simply let <img class="center" src="figs/img88.png" alt=""> in this case. 
If we still find a loop after this, we generate another pair <img class="center" src="figs/img89.png" alt="">.
When a multiple edge occurs we abort and generate a new pair <img class="center" src="figs/img89.png" alt="">. 
Although the function above causes <a href="concepts.html">collisions</a> with probability <em>1/t</em>,
in <a href="index.html">cmph library</a> we use faster hash 
functions (<a href="http://www.cs.yorku.ca/~oz/hash.html">DJB2 hash</a>, <a href="http://www.isthe.com/chongo/tech/comp/fnv/">FNV hash</a>,
 <a href="http://burtleburtle.net/bob/hash/doobs.html">Jenkins hash</a> and <a href="http://www.cs.yorku.ca/~oz/hash.html">SDBM hash</a>) 
 in which we do not need to impose any upper bound <img class="center" src="figs/img79.png" alt=""> on the lengths of the keys in <img class="center" src="figs/img20.png" alt="">.
</p>
<p>
As mentioned before, for us to find  the labelling <img class="center" src="figs/img72.png" alt=""> of the 
vertices of <img class="center" src="figs/img59.png" alt=""> in linear time,
we require that <img class="center" src="figs/img108.png" alt="">. 
The crucial step now is to determine the value 
of <img class="center" src="figs/img1.png" alt=""> (in <img class="center" src="figs/img57.png" alt="">) to obtain a random 
graph <img class="center" src="figs/img71.png" alt=""> with <img class="center" src="figs/img109.png" alt="">.
Botelho, Menoti an Ziviani determinded emprically in <a href="#papers">[1</a>] that 
the value of <img class="center" src="figs/img1.png" alt=""> is <em>1.15</em>. This value is remarkably
close to the theoretical value determined in <a href="#papers">[2</a>], 
which is around <img class="center" src="figs/img112.png" alt="">.
</p>

<hr class="light">

</section>
<section>
<h3>Ordering Step</h3>

<p>
The procedure Ordering (<img class="center" src="figs/img32.png" alt="">, <img class="center" src="figs/img63.png" alt="">, <img class="center" src="figs/img70.png" alt="">) receives 
as input the graph <img class="center" src="figs/img32.png" alt=""> and partitions <img class="center" src="figs/img32.png" alt=""> into the two 
subgraphs <img class="center" src="figs/img63.png" alt=""> and <img class="center" src="figs/img70.png" alt="">, so that <img class="center" src="figs/img71.png" alt="">.
</p>
<p>
Figure 2 presents a sample graph with 9 vertices
and 8 edges, where the degree of a vertex is shown besides each vertex.
Initially, all vertices with degree 1 are added to a queue <img class="center" src="figs/img136.png" alt="">.
For the example shown in Figure 2(a), <img class="center" src="figs/img137.png" alt=""> after the initialization step.
</p>

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><img class="center" src="figs/img138.png" alt=""></td>
</tr>
<tr>
<td><strong>Figure 2:</strong> Ordering step for a graph with 9 vertices and 8 edges.</td>
</tr>
</table>

<p>
Next, we remove one vertex <img class="center" src="figs/img139.png" alt=""> from the queue, decrement its degree and
the degree of the vertices with degree greater than 0 in the adjacent
list of <img class="center" src="figs/img139.png" alt="">, as depicted in Figure 2(b) for <img class="center" src="figs/img140.png" alt="">.
At this point, the adjacencies of <img class="center" src="figs/img139.png" alt=""> with degree 1 are
inserted into the queue, such as vertex 1.
This process is repeated until the queue becomes empty.
All vertices with degree 0 are non-critical vertices and the others are
critical vertices, as depicted in Figure 2(c).
Finally, to determine the vertices in <img class="center" src="figs/img141.png" alt=""> we collect all 
vertices <img class="center" src="figs/img142.png" alt=""> with at least one vertex <img class="center" src="figs/img143.png" alt=""> that 
is in Adj<img class="center" src="figs/img144.png" alt=""> and in <img class="center" src="figs/img145.png" alt="">, as the vertex 8 in Figure 2(c).
</p>

<hr class="light">

</section>
<section>
<h3>Searching Step</h3>

<p>
In the searching step, the key part is
the <em>perfect assignment problem</em>: find <img class="center" src="figs/img153.png" alt=""> such that
the function <img class="center" src="figs/img154.png" alt=""> defined by
</p>

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><img class="center" src="figs/img155.png" alt=""></td>
</tr>
</table>

<p>
is a bijection from <img class="center" src="figs/img156.png" alt=""> to <img class="center" src="figs/img157.png" alt=""> (recall <img class="center" src="figs/img158.png" alt="">).
We are interested in a labelling <img class="center" src="figs/img72.png" alt=""> of
the vertices of the graph <img class="center" src="figs/img59.png" alt=""> with
the property that if <img class="center" src="figs/img11.png" alt=""> and <img class="center" src="figs/img22.png" alt=""> are keys 
in <img class="center" src="figs/img20.png" alt="">, then <img class="center" src="figs/img159.png" alt="">; that is, if we associate
to each edge the sum of the labels on its endpoints, then these values
should be all distinct.
Moreover, we require that all the sums <img class="center" src="figs/img160.png" alt=""> (<img class="center" src="figs/img18.png" alt="">)
fall between <img class="center" src="figs/img115.png" alt=""> and <img class="center" src="figs/img161.png" alt="">, and thus we have a bijection
between <img class="center" src="figs/img20.png" alt=""> and <img class="center" src="figs/img157.png" alt="">.
</p>
<p>
The procedure Searching (<img class="center" src="figs/img32.png" alt="">, <img class="center" src="figs/img63.png" alt="">, <img class="center" src="figs/img70.png" alt="">, <img class="center" src="figs/img37.png" alt="">)
receives as input <img class="center" src="figs/img32.png" alt="">, <img class="center" src="figs/img63.png" alt="">, <img class="center" src="figs/img70.png" alt=""> and finds a 
suitable <img class="center" src="figs/img162.png" alt=""> bit value for each vertex <img class="center" src="figs/img74.png" alt="">, stored in the
array <img class="center" src="figs/img37.png" alt="">.
This step is first performed for the vertices in the
critical subgraph <img class="center" src="figs/img63.png" alt=""> of <img class="center" src="figs/img32.png" alt=""> (the 2-core of <img class="center" src="figs/img32.png" alt="">) 
and then it is performed for the vertices in <img class="center" src="figs/img70.png" alt=""> (the non-critical subgraph
of <img class="center" src="figs/img32.png" alt=""> that contains the "acyclic part" of <img class="center" src="figs/img32.png" alt="">).
The reason the assignment of the <img class="center" src="figs/img37.png" alt=""> values is first
performed on the vertices in <img class="center" src="figs/img63.png" alt=""> is to resolve reassignments
as early as possible (such reassignments are consequences of the cycles
in <img class="center" src="figs/img63.png" alt=""> and are depicted hereinafter).
</p>

<hr class="light">

<section>
<h4>Assignment of Values to Critical Vertices</h4>

<p>
The labels <img class="center" src="figs/img73.png" alt=""> (<img class="center" src="figs/img142.png" alt="">)
are assigned in increasing order following a greedy
strategy where the critical vertices <img class="center" src="figs/img139.png" alt=""> are considered one at a time,
according to a breadth-first search on <img class="center" src="figs/img63.png" alt="">.
If a candidate value <img class="center" src="figs/img11.png" alt=""> for <img class="center" src="figs/img73.png" alt=""> is forbidden
because setting <img class="center" src="figs/img163.png" alt=""> would create two edges with the same sum,
we try <img class="center" src="figs/img164.png" alt=""> for <img class="center" src="figs/img73.png" alt="">. This fact is referred to 
as a <em>reassignment</em>.
</p>
<p>
Let <img class="center" src="figs/img165.png" alt=""> be the set of addresses assigned to edges in <img class="center" src="figs/img166.png" alt="">.
Initially <img class="center" src="figs/img167.png" alt="">.
Let <img class="center" src="figs/img11.png" alt=""> be a candidate value for <img class="center" src="figs/img73.png" alt="">.
Initially <img class="center" src="figs/img168.png" alt="">.
Considering the subgraph <img class="center" src="figs/img63.png" alt=""> in Figure 2(c),
a step by step example of the assignment of values to vertices in <img class="center" src="figs/img63.png" alt=""> is 
presented in Figure 3.
Initially, a vertex <img class="center" src="figs/img139.png" alt=""> is chosen, the assignment <img class="center" src="figs/img163.png" alt=""> is made
and <img class="center" src="figs/img11.png" alt=""> is set to <img class="center" src="figs/img164.png" alt="">.
For example, suppose that vertex <img class="center" src="figs/img169.png" alt=""> in Figure 3(a) is 
chosen, the assignment <img class="center" src="figs/img170.png" alt=""> is made and <img class="center" src="figs/img11.png" alt=""> is set to <img class="center" src="figs/img96.png" alt="">.
</p>

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><img class="center" src="figs/img171.png" alt=""></td>
</tr>
<tr>
<td><strong>Figure 3:</strong> Example of the assignment of values to critical vertices.</td>
</tr>
</table>

<p>
In Figure 3(b), following the adjacent list of vertex <img class="center" src="figs/img169.png" alt="">,
the unassigned vertex <img class="center" src="figs/img115.png" alt=""> is reached.
At this point, we collect in the temporary variable <img class="center" src="figs/img172.png" alt=""> all adjacencies 
of vertex <img class="center" src="figs/img115.png" alt=""> that have been assigned an <img class="center" src="figs/img11.png" alt=""> value, 
and <img class="center" src="figs/img173.png" alt="">.
Next, for all <img class="center" src="figs/img174.png" alt="">, we check if <img class="center" src="figs/img175.png" alt="">.
Since <img class="center" src="figs/img176.png" alt="">, then <img class="center" src="figs/img177.png" alt=""> is set 
to <img class="center" src="figs/img96.png" alt="">, <img class="center" src="figs/img11.png" alt=""> is incremented 
by 1 (now <img class="center" src="figs/img178.png" alt="">) and <img class="center" src="figs/img179.png" alt="">.
Next, vertex <img class="center" src="figs/img180.png" alt=""> is reached, <img class="center" src="figs/img181.png" alt=""> is set 
to <img class="center" src="figs/img62.png" alt="">, <img class="center" src="figs/img11.png" alt=""> is set to <img class="center" src="figs/img180.png" alt=""> and <img class="center" src="figs/img182.png" alt="">.
Next, vertex <img class="center" src="figs/img183.png" alt=""> is reached and <img class="center" src="figs/img184.png" alt="">.
Since <img class="center" src="figs/img185.png" alt=""> and <img class="center" src="figs/img186.png" alt="">, then <img class="center" src="figs/img187.png" alt=""> is 
set to <img class="center" src="figs/img180.png" alt="">, <img class="center" src="figs/img11.png" alt=""> is set to <img class="center" src="figs/img183.png" alt=""> and <img class="center" src="figs/img188.png" alt="">.
Finally, vertex <img class="center" src="figs/img189.png" alt=""> is reached and <img class="center" src="figs/img190.png" alt="">.
Since <img class="center" src="figs/img191.png" alt="">, <img class="center" src="figs/img11.png" alt=""> is incremented by 1 and set to 5, as depicted in 
Figure 3(c).
Since <img class="center" src="figs/img192.png" alt="">, <img class="center" src="figs/img11.png" alt=""> is again incremented by 1 and set to 6, 
as depicted in Figure 3(d).
These two reassignments are indicated by the arrows in Figure 3.
Since <img class="center" src="figs/img193.png" alt=""> and <img class="center" src="figs/img194.png" alt="">, then <img class="center" src="figs/img195.png" alt=""> is set 
to <img class="center" src="figs/img196.png" alt=""> and <img class="center" src="figs/img197.png" alt="">. This finishes the algorithm.
</p>

<hr class="light">

</section>
<section>
<h4>Assignment of Values to Non-Critical Vertices</h4>

<p>
As <img class="center" src="figs/img70.png" alt=""> is acyclic, we can impose the order in which addresses are
associated with edges in <img class="center" src="figs/img70.png" alt="">, making this step simple to solve
by a standard depth first search algorithm.
Therefore, in the assignment of values to vertices in <img class="center" src="figs/img70.png" alt=""> we
benefit from the unused addresses in the gaps left by the assignment of values
to vertices in <img class="center" src="figs/img63.png" alt="">.
For that, we start the depth-first search from the vertices in <img class="center" src="figs/img141.png" alt=""> because 
the <img class="center" src="figs/img37.png" alt=""> values for these critical vertices were already assigned
and cannot be changed.
</p>
<p>
Considering the subgraph <img class="center" src="figs/img70.png" alt=""> in Figure 2(c),
a step by step example of the assignment of values to vertices in <img class="center" src="figs/img70.png" alt=""> is 
presented in Figure 4.
Figure 4(a) presents the initial state of the algorithm.
The critical vertex 8 is the only one that has non-critical vertices as
adjacent.
In the example presented in Figure 3, the addresses <img class="center" src="figs/img198.png" alt=""> were not used.
So, taking the first unused address <img class="center" src="figs/img115.png" alt=""> and the vertex <img class="center" src="figs/img96.png" alt="">, 
which is reached from the vertex <img class="center" src="figs/img169.png" alt="">, <img class="center" src="figs/img199.png" alt=""> is set 
to <img class="center" src="figs/img200.png" alt="">, as shown in Figure 4(b).
The only vertex that is reached from vertex <img class="center" src="figs/img96.png" alt=""> is vertex <img class="center" src="figs/img62.png" alt="">, so
taking the unused address <img class="center" src="figs/img183.png" alt=""> we set <img class="center" src="figs/img201.png" alt=""> to <img class="center" src="figs/img202.png" alt="">,
as shown in Figure 4(c).
This process is repeated until the UnAssignedAddresses list becomes empty.
</p>

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><img class="center" src="figs/img203.png" alt=""></td>
</tr>
<tr>
<td><strong>Figure 4:</strong> Example of the assignment of values to non-critical vertices.</td>
</tr>
</table>

<hr class="light">

</section>
</section>
</section>
<section id="heuristic">
<h2>The Heuristic</h2>

<p>
We now present an heuristic for BMZ algorithm that 
reduces the value of <img class="center" src="figs/img1.png" alt=""> to any given value between <em>1.15</em> and <em>0.93</em>.
This reduces the space requirement to store the resulting function 
to any given value between <img class="center" src="figs/img12.png" alt=""> words and <img class="center" src="figs/img13.png" alt=""> words.
The heuristic reuses, when possible, the set 
of <img class="center" src="figs/img11.png" alt=""> values that caused reassignments, just before 
trying <img class="center" src="figs/img164.png" alt="">.
Decreasing the value of <img class="center" src="figs/img1.png" alt=""> leads to an increase in the number of 
iterations to generate <img class="center" src="figs/img32.png" alt="">.
For example, for <img class="center" src="figs/img244.png" alt=""> and <img class="center" src="figs/img6.png" alt="">, the analytical expected number 
of iterations are <img class="center" src="figs/img245.png" alt=""> and <img class="center" src="figs/img246.png" alt="">, respectively (see <a href="#papers">[2</a>] 
for details),
while for <img class="center" src="figs/img128.png" alt=""> the same value is around <em>2.13</em>.
</p>

<hr class="light">

</section>
<section>
<h2>Memory Consumption</h2>

<p>
Now we detail the memory consumption to generate and to store minimal perfect hash functions
using the BMZ algorithm. The structures responsible for memory consumption are in the 
following:
</p>

<ul>
<li>Graph:
  <ol>
  <li><strong>first</strong>: is a vector that stores <em>cn</em> integer numbers, each one representing 
    the first edge (index in the vector edges) in the list of 
    edges of each vertex. 
    The integer numbers are 4 bytes long. Therefore,
    the vector first is stored in <em>4cn</em> bytes.
  <p></p>
  </li>
  <li><strong>edges</strong>: is a vector to represent the edges of the graph. As each edge
    is compounded by a pair of vertices, each entry stores two integer numbers 
    of 4 bytes that represent the vertices. As there are <em>n</em> edges, the 
    vector edges is stored in <em>8n</em> bytes. 
  <p></p>
  </li>
  <li><strong>next</strong>: given a vertex <img class="center" src="figs/img139.png" alt="">, we can discover the edges that 
    contain <img class="center" src="figs/img139.png" alt=""> following its list of edges, 
    which starts on first[<img class="center" src="figs/img139.png" alt="">] and the next
    edges are given by next[...first[<img class="center" src="figs/img139.png" alt="">]...]. Therefore, the vectors first and next represent 
    the linked lists of edges of each vertex. As there are two vertices for each edge,
    when an edge is iserted in the graph, it must be inserted in the two linked lists 
    of the vertices in its composition. Therefore, there are <em>2n</em> entries of integer
    numbers in the vector next, so it is stored in <em>4*2n = 8n</em> bytes.
  <p></p>
  </li>
  <li><strong>critical vertices(critical_nodes vector)</strong>: is a vector of <em>cn</em> bits, 
    where each bit indicates if a vertex is critical (1) or non-critical (0). 
    Therefore, the critical and non-critical vertices are represented in <em>cn/8</em> bytes.
  <p></p>
  </li>
  <li><strong>critical edges (used_edges vector)</strong>: is a vector of <em>n</em> bits, where each 
    bit indicates if an edge is critical (1) or non-critical (0). Therefore, the 
    critical and non-critical edges are represented in <em>n/8</em> bytes. 
  <p></p>
  </li>
  </ol>
</li>
<li>Other auxiliary structures 
  <ol>
  <li><strong>queue</strong>: is a queue of integer numbers used in the breadth-first search of the
    assignment of values to critical vertices. There is an entry in the queue for 
    each two critical vertices. Let <img class="center" src="figs/img110.png" alt=""> be the expected number of critical 
    vertices. Therefore, the queue is stored in <em>4*0.5*<img class="center" src="figs/img110.png" alt="">=2<img class="center" src="figs/img110.png" alt=""></em>.
  <p></p>
  </li>
  <li><strong>visited</strong>: is a vector of <em>cn</em> bits, where each bit indicates if the g value of 
    a given vertex was already defined. Therefore, the vector visited is stored
    in <em>cn/8</em> bytes.
  <p></p>
  </li>
  <li><strong>function <em>g</em></strong>: is represented by a vector of <em>cn</em> integer numbers.
    As each integer number is 4 bytes long, the function <em>g</em> is stored in
    <em>4cn</em> bytes. 
  </li>
  </ol>
</li>
</ul>

<p>
Thus, the total memory consumption of BMZ algorithm for generating a minimal 
perfect hash function (MPHF) is: <em>(8.25c + 16.125)n +2<img class="center" src="figs/img110.png" alt=""> + O(1)</em> bytes.
As the value of constant <em>c</em> may be 1.15 and 0.93 we have:
</p>

<table style="margin-left: auto; margin-right: auto;" class="tableborder">
<tr>
<th><em>c</em></th>
<th><img class="center" src="figs/img110.png" alt=""></th>
<th>Memory consumption to generate a MPHF</th>
</tr>
<tr>
<td>0.93</td>
<td class="center"><em>0.497n</em></td>
<td class="center"><em>24.80n + O(1)</em></td>
</tr>
<tr>
<td>1.15</td>
<td class="center"><em>0.401n</em></td>
<td class="center"><em>26.42n + O(1)</em></td>
</tr>
</table>

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><strong>Table 1:</strong> Memory consumption to generate a MPHF using the BMZ algorithm.</td>
</tr>
</table>

<p>
The values of <img class="center" src="figs/img110.png" alt=""> were calculated using Eq.(1) presented in <a href="#papers">[2</a>].
</p>
<p>
Now we present the memory consumption to store the resulting function.
We only need to store the <em>g</em> function. Thus, we need <em>4cn</em> bytes.
Again we have:
</p>

<table style="margin-left: auto; margin-right: auto;" class="tableborder">
<tr>
<th><em>c</em></th>
<th>Memory consumption to store a MPHF</th>
</tr>
<tr>
<td>0.93</td>
<td class="center"><em>3.72n</em></td>
</tr>
<tr>
<td>1.15</td>
<td class="center"><em>4.60n</em></td>
</tr>
</table>

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><strong>Table 2:</strong> Memory consumption to store a MPHF generated by the BMZ algorithm.</td>
</tr>
</table>

<hr class="light">

</section>
<section>
<h2>Experimental Results</h2>

<p>
<a href="comparison.html">CHM x BMZ</a>
</p>

<hr class="light">

</section>
<section id="papers">
<h2>Papers</h2>

<ol>
<li><a href="http://www.dcc.ufmg.br/~fbotelho">F. C. Botelho</a>, D. Menoti, <a href="http://www.dcc.ufmg.br/~nivio">N. Ziviani</a>. <a href="papers/bmz_tr004_04.ps">A New algorithm for constructing minimal perfect hash functions</a>, Technical Report TR004/04, Department of Computer Science, Federal University of Minas Gerais, 2004.
<p></p>
</li>
<li><a href="http://www.dcc.ufmg.br/~fbotelho">F. C. Botelho</a>, Y. Kohayakawa, and <a href="http://www.dcc.ufmg.br/~nivio">N. Ziviani</a>. <a href="papers/bmz_wea2005.ps">A Practical Minimal Perfect Hashing Method</a>. <em>4th International Workshop on efficient and Experimental Algorithms (WEA05),</em> Springer-Verlag Lecture Notes in Computer Science, vol. 3505, Santorini Island, Greece, May 2005, 488-500.
</li>
</ol>

<hr class="light">

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><a href="index.html">Home</a></td>
<td><a href="chd.html">CHD</a></td>
<td><a href="bdz.html">BDZ</a></td>
<td><a href="bmz.html">BMZ</a></td>
<td><a href="chm.html">CHM</a></td>
<td><a href="brz.html">BRZ</a></td>
<td><a href="fch.html">FCH</a></td>
</tr>
</table>

<hr class="light">

<p>
Enjoy!
</p>
<p>
<a href="mailto:davi@users.sourceforge.net">Davi de Castro Reis</a>
</p>
<p>
<a href="mailto:db8192@users.sourceforge.net">Djamel Belazzougui</a>
</p>
<p>
<a href="mailto:fc_botelho@users.sourceforge.net">Fabiano Cupertino Botelho</a>
</p>
<p>
<a href="mailto:nivio@dcc.ufmg.br">Nivio Ziviani</a>
</p>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7698683-2");
pageTracker._trackPageview();
} catch(err) {}</script>
</section>
</section>
</div>

<!-- html code generated by txt2tags 3.3 (http://txt2tags.org) -->
<!-- cmdline: txt2tags -t html -i BMZ.t2t -o bmz.html -->
</article></body></html>
