<!DOCTYPE html>
<html>
<head>
<title>Compress, Hash and Displace: CHD Algorithm</title>
<meta name="generator" content="http://txt2tags.org">
<link rel="stylesheet" href="DOC.css">
<style>
body{background-color:#fff;color:#000;}
hr{background-color:#000;border:0;color:#000;}
hr.heavy{height:5px;}
hr.light{height:1px;}
img{border:0;display:block;}
img.right{margin:0 0 0 auto;}
img.center{border:0;margin:0 auto;}
table th,table td{padding:4px;}
.center,header{text-align:center;}
table.center {margin-left:auto; margin-right:auto;}
.right{text-align:right;}
.left{text-align:left;}
.tableborder,.tableborder td,.tableborder th{border:1px solid #000;}
.underline{text-decoration:underline;}
</style>
</head>
<body>
<header>
<hgroup>
<h1>Compress, Hash and Displace: CHD Algorithm</h1>
</hgroup>
</header>
<article>

<div class="body" id="body">

<section~A~>
<h1></h1>
<section>
<h2>Properties</h2>

  <ul>
  <li>It is the fastest algorithm to build PHFs and MPHFs in linear time.
  </li>
  <li>It generates the most compact PHFs and MPHFs we know of.
  </li>
  <li>The resulting MPHFs are not order preserving.
  </li>
  <li>It can generate PHFs with a load factor up to <em>99 %</em>.
  </li>
  <li>It can be used to generate <em>t</em>-perfect hash functions. A <em>t</em>-perfect hash function allows at most <em>t</em> collisions in a given bin. It is a well-known fact that modern memories are organized as blocks which constitute transfer unit. Example of such blocks are cache lines for internal memory or sectors for hard disks. Thus, it can be very useful for devices that carry out I/O operations in blocks.   
  </li>
  <li>It is a two level scheme. It uses a first level hash function to split the key set in buckets of average size determined by a parameter <em>b</em> in the range <em>[1,32]</em>. In the second level it uses displacement values to resolve the collisions that have given rise to the buckets.
  </li>
  <li>It can generate MPHFs that can be stored in approximately <em>2.07</em> bits per key.
  </li>
  <li>For a load factor equal to the maximum one that is achieved by the BDZ algorithm (<em>81 %</em>), the resulting PHFs are stored in approximately <em>1.40</em> bits per key. 
  <p></p>
  </li>
  </ul>

<hr class="light">

</section>
<section>
<h2>Introduction</h2>

<p>
The important performance parameters of a PHF are representation size, evaluation time and construction time. The representation size plays an important role when the whole function fits in a faster memory and the actual data is stored in a slower memory. For instace, compact PHFs can be entirely fit in a CPU cache and this makes their computation really fast by avoiding cache misses. The CHD algorithm plays an important role in this context. It was designed by Djamal Belazzougui, Fabiano C. Botelho, and Martin Dietzfelbinger in <a href="#papers">[2</a>].
</p>
<p>
The CHD algorithm permits to obtain PHFs with representation size very close to optimal while retaining <em>O(n)</em> construction time and <em>O(1)</em> evaluation time. For example, in the case <em>m=2n</em> we obtain a PHF that uses space <em>0.67</em> bits per key, and for <em>m=1.23n</em> we obtain space <em>1.4</em> bits per key, which was not achievable with previously known methods. The CHD algorithm is inspired by several known algorithms; the main new feature is that it combines a modification of Pagh's ``hash-and-displace'' approach with data compression on a sequence of hash function indices. That combination makes it possible to significantly reduce space usage while retaining linear construction time and constant query time. The CHD algorithm can also be used for <em>k</em>-perfect hashing, where at most <em>k</em> keys may be mapped to the same value. For the analysis we assume that fully random hash functions are given for free; such assumptions can be justified and were made in previous papers.
</p>
<p>
The compact PHFs generated by the CHD algorithm can be used in many applications in which we want to assign a unique identifier to each key without storing any information on the key. One of the most obvious applications of those functions (or <em>k</em>-perfect hash functions) is when we have a small fast memory in which we can store the perfect hash function while the keys and associated satellite data are stored in slower but larger memory. The size of a block or a transfer unit may be chosen so that <em>k</em> data items can be retrieved in one read access. In this case we can ensure that data associated with a key can be retrieved in a single probe to slower memory. This has been used for example in hardware routers <a href="#papers">[4</a>]. 
</p>
<p>
The CHD algorithm generates the most compact PHFs and MPHFs we know of in <em>O(n)</em> time. The time required to evaluate the generated functions is constant (in practice less than <em>1.4</em> microseconds). The storage space of the resulting PHFs and MPHFs are distant from the information theoretic lower bound by a factor of <em>1.43</em>. The closest competitor is the algorithm by Martin and Pagh <a href="#papers">[3</a>] but their algorithm do not work in linear time. Furthermore, the CHD algorithm can be tuned to run faster than the BPZ algorithm <a href="#papers">[1</a>] (the fastest algorithm available in the literature so far) and to obtain more compact functions. The most impressive characteristic is that it has the ability, in principle, to approximate the information theoretic lower bound while being practical. A detailed description of the CHD algorithm can be found in <a href="#papers">[2</a>]. 
</p>

<hr class="light">

</section>
<section>
<h2>Experimental Results</h2>

<p>
Experimental results comparing the CHD algorithm with <a href="bdz.html">the BDZ algorithm</a>
and others available in the CMPH library are presented in <a href="#papers">[2</a>].
</p>

<hr class="light">

</section>
<section id="papers">
<h2>Papers</h2>

<ol>
<li><a href="http://www.dcc.ufmg.br/~fbotelho">F. C. Botelho</a>, <a href="http://www.itu.dk/~pagh/">R. Pagh</a>, <a href="http://www.dcc.ufmg.br/~nivio">N. Ziviani</a>. <a href="papers/wads07.pdf">Simple and space-efficient minimal perfect hash functions</a>. <em>In Proceedings of the 10th International Workshop on Algorithms and Data Structures (WADs'07),</em> Springer-Verlag Lecture Notes in Computer Science, vol. 4619, Halifax, Canada, August 2007, 139-150.
<p></p>
</li>
<li><a href="http://www.dcc.ufmg.br/~fbotelho">F. C. Botelho</a>, D. Belazzougui and M. Dietzfelbinger. <a href="papers/esa09.pdf">Compress, hash and displace</a>. <em>In Proceedings of the 17th European Symposium on Algorithms (ESA’09)</em>. Springer LNCS, 2009.
<p></p>
</li>
<li>M. Dietzfelbinger and <a href="http://www.itu.dk/~pagh/">R. Pagh</a>. Succinct data structures for retrieval and approximate membership. <em>In Proceedings of the 35th international colloquium on Automata, Languages and Programming (ICALP’08)</em>, pages 385–396, Berlin, Heidelberg, 2008. Springer-Verlag.
<p></p>
</li>
<li>B. Prabhakar and F. Bonomi. Perfect hashing for network applications. <em>In Proceedings of the IEEE International Symposium on Information Theory</em>. IEEE Press, 2006.
</li>
</ol>

<hr class="light">

<table style="margin-left: auto; margin-right: auto;">
<tr>
<td><a href="index.html">Home</a></td>
<td><a href="chd.html">CHD</a></td>
<td><a href="bdz.html">BDZ</a></td>
<td><a href="bmz.html">BMZ</a></td>
<td><a href="chm.html">CHM</a></td>
<td><a href="brz.html">BRZ</a></td>
<td><a href="fch.html">FCH</a></td>
</tr>
</table>

<hr class="light">

<p>
Enjoy!
</p>
<p>
<a href="mailto:davi@users.sourceforge.net">Davi de Castro Reis</a>
</p>
<p>
<a href="mailto:db8192@users.sourceforge.net">Djamel Belazzougui</a>
</p>
<p>
<a href="mailto:fc_botelho@users.sourceforge.net">Fabiano Cupertino Botelho</a>
</p>
<p>
<a href="mailto:nivio@dcc.ufmg.br">Nivio Ziviani</a>
</p>
<p>
<a href="https://github.com/rurban/">Reini Urban</a>
</p>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7698683-2");
pageTracker._trackPageview();
} catch(err) {}</script>
</section>
</section>
</div>

<!-- html code generated by txt2tags 3.3 (http://txt2tags.org) -->
<!-- cmdline: txt2tags -t html -i CHD.t2t -o chd.html -->
</article></body></html>
